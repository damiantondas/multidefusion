{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to multidefusion","text":"<p>Perform data fusion and analysis of the ground deformations for multiple stations.</p> <ul> <li>Free software: MIT license</li> <li>Documentation: https://damiantondas.github.io/multidefusion</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#multidefusion.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>multidefusion\\common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\n    \"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/damiantondas/multidefusion/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>multidefusion could always use more documentation, whether as part of the official multidefusion docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/damiantondas/multidefusion/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up multidefusion for local development.</p> <ol> <li> <p>Fork the multidefusion repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/multidefusion.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv multidefusion\n$ cd multidefusion/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 multidefusion tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and     for PyPy. Check https://github.com/damiantondas/multidefusion/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install multidefusion, run this command in your terminal:</p> <pre><code>pip install multidefusion\n</code></pre> <p>This is the preferred method to install multidefusion, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install multidefusion from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/damiantondas/multidefusion\n</code></pre>"},{"location":"multidefusion/","title":"multidefusion module","text":"<p>Main module.</p>"},{"location":"results/","title":"results module","text":""},{"location":"results/#multidefusion.results.Figures","title":"<code>Figures</code>","text":"<p>Class for creating displacement plots.</p> Source code in <code>multidefusion\\results.py</code> <pre><code>class Figures:\n    \"\"\"Class for creating displacement plots.\"\"\"\n    def __init__(self, data_integration):\n        \"\"\"\n        Initialize Figures object.\n\n        Args:\n            data_integration (object): Object containing integrated data.\n        \"\"\"\n        self.data_integration = data_integration\n        sar_data = self.data_integration.data_dict.get(\"SAR\")\n        if sar_data is not None:\n            list_of_orbits = list(set(orbit for technique_data in sar_data.values() for orbit in technique_data))\n            list_of_orbits = [int(x) for x in list_of_orbits]\n            list_of_orbits.sort()\n            list_of_orbits = [str(x) for x in list_of_orbits]\n            self.orbits = list_of_orbits\n            self.number_of_orbits = len(self.orbits)\n            self.sar_data_types = list(set([data for data in self.data_integration.data_dict.get(\"SAR\").keys()]))\n        else:\n            self.orbits = []\n            self.number_of_orbits = 0\n            self.sar_data_types = []\n\n    @staticmethod\n    def find_min_value(*lists):\n        \"\"\"\n        Find the minimum value from a set of lists.\n\n        Args:\n            *lists: Variable number of lists to find the minimum value from.\n\n        Returns:\n            Minimum value from the provided lists.\n        \"\"\"\n        if not lists:\n            return None\n        flattened_list = [item for sublist in lists for item in sublist]\n        return min(flattened_list)\n\n    @staticmethod\n    def find_max_value(*lists):\n        \"\"\"\n        Find the maximum value from a set of lists.\n\n        Args:\n            *lists: Variable number of lists to find the maximum value from.\n\n        Returns:\n            Maximum value from the provided lists.\n        \"\"\"\n        if not lists:\n            return None\n        flattened_list = [item for sublist in lists for item in sublist]\n        return max(flattened_list)\n\n    @staticmethod\n    def find_max_total(df):\n        return df.apply(lambda col: col.max() if col.max() &gt;= -col.min() else col.min(), axis=0)\n\n    @staticmethod\n    def add_vline(fig, timestamp_min_value, timestamp_max_value, row, col):    \n        # THICKER LINE TO INDICATE THE BEGINNING OF THE YEAR\n\n        [fig.add_shape(x0=date, x1=date, y0=-10, y1=10, type=\"line\", line=dict(color='lightgray', width=2), layer=\"below\", row=row, col=col) for date in\n        pd.date_range(start=timestamp_min_value - relativedelta(years=2),\n        end=timestamp_max_value + relativedelta(years=2), freq='YS')]\n\n    def create_displacement_plot(self):\n        \"\"\"\n        Create displacement plot using Plotly and Dash.\n        \"\"\"\n        # SETTINGS\n        print(\"Development of a figure...\")\n        additional_range = 0.05  # additional +/-5% of range for plots by x and y axis\n        golden_ratio = (1 + 5 ** 0.5) / 2  # for size on y axis\n        subplots_postition = {'3*': [[0.019, 0.335], [0.342, 0.658], [0.665, 0.981]],\n                              '3' : [[0.000, 0.316], [0.323, 0.639], [0.684, 1.000]],\n                              '2' : [[0.1805, 0.4965], [0.5035, 0.8195]],\n                              '1' : [[0.323, 0.639]]}\n\n        shift_rate_fig  = 0.007\n        shift_disp_fig  = 0.100\n        shift_title_fig = 0.003\n        shift_legend    = 0.030\n        rate_fig_size   = 7/25\n        top_limit_plot  = 0.970\n        vertical_postition = {}\n        vertical_postition['1']  = [top_limit_plot-subplots_postition['3'][0][1]/golden_ratio, top_limit_plot]\n        vertical_postition['2']  = [vertical_postition['1'][0]-subplots_postition['3'][0][1]/golden_ratio*rate_fig_size-shift_rate_fig , vertical_postition['1'][0]-shift_rate_fig]\n        vertical_postition['3*'] = [vertical_postition['2'][0]-subplots_postition['3'][0][1]/golden_ratio*rate_fig_size-shift_disp_fig , vertical_postition['2'][0]-shift_disp_fig]\n        vertical_postition['3']  = [vertical_postition['2'][0]-subplots_postition['3'][0][1]/golden_ratio              -shift_disp_fig , vertical_postition['2'][0]-shift_disp_fig]\n        vertical_postition['4']  = [vertical_postition['3'][0]-subplots_postition['3'][0][1]/golden_ratio*rate_fig_size-shift_rate_fig , vertical_postition['3'][0]-shift_rate_fig]\n\n        table_postition = {'GNSS'  : [vertical_postition['2'][0]-subplots_postition['3'][0][1]/golden_ratio-shift_disp_fig, vertical_postition['2'][0]-shift_disp_fig],\n                           'DInSAR': [vertical_postition['3*'][0]-subplots_postition['3'][0][1]/golden_ratio-shift_disp_fig, vertical_postition['3*'][0]-shift_disp_fig],\n                           'SBAS'  : [vertical_postition['3'][0]-subplots_postition['3'][0][1]/golden_ratio-shift_disp_fig, vertical_postition['3'][0]-shift_disp_fig],\n                           'MSAR'  : [vertical_postition['4'][0]-subplots_postition['3'][0][1]/golden_ratio-shift_disp_fig, vertical_postition['4'][0]-shift_disp_fig]}\n\n        shift_dash = 0\n        max_len_elements = max(len(lst) for lst in self.data_integration.number_of_SAR_elements.values())\n        if max_len_elements &gt; 2:\n            shift_dash = (max_len_elements-2)*7\n\n        custom_position = {'GNSS'  : 558,\n                           'DInSAR': 754+shift_dash,\n                           'SBAS'  : 929+shift_dash,\n                           'MSAR'  : 1009+shift_dash}\n\n        rows = 3\n        cols = 3\n        specs = [[{\"type\": \"xy\"}] * cols for _ in range(rows-1)]\n\n        name_forward = \"Forward\"\n        name_backward = \"Backward\"\n\n        GNSS_names = [\"North\", \"East\", \"Up\"]\n        disp_names = [\"N\", \"E\", \"U\"]\n        disp_units = {\"U\": \"ver\", \"N\": \"hor\", \"E\": \"hor\"}\n\n        subplot_titles = [f\"&lt;b&gt;{GNSS_names[0]}&lt;/b&gt;\", f\"&lt;b&gt;{GNSS_names[1]}&lt;/b&gt;\", f\"&lt;b&gt;{GNSS_names[2]}&lt;/b&gt;\"] + [''] * cols\n\n        orbit_titles = [\"&lt;b&gt;Orbit \" + orbit + \"&lt;/b&gt;\" for orbit in self.orbits]\n        empty_titles = [\"\"] * (3 - self.number_of_orbits)\n        # CREATE GRID FOR SUBPLOTS AND TITLES\n        if \"PSI\" in self.sar_data_types or \"SBAS\" in self.sar_data_types:\n            rows += 1\n            subplot_titles.extend(orbit_titles + empty_titles)\n\n            specs_temp = [[{\"type\": \"xy\"}] * self.number_of_orbits + [None] * (3 - self.number_of_orbits)]\n            specs.extend(specs_temp)\n\n        if \"DInSAR\" in self.sar_data_types:\n            rows += 1\n            specs_temp = [[{\"type\": \"xy\"}] * self.number_of_orbits + [None] * (3 - self.number_of_orbits)]\n            specs.extend(specs_temp)\n            if \"PSI\" not in self.sar_data_types and \"SBAS\" not in self.sar_data_types:\n                subplot_titles.extend(orbit_titles + empty_titles)\n            else:\n                subplot_titles.extend([\"\"] * self.number_of_orbits)\n\n        specs_temp = [ [{\"type\": \"table\"}] + [None]*2]\n        specs.extend(specs_temp)\n\n        # CREATE FIG OBJECT\n        fig = sp.make_subplots(rows=rows, cols=cols,\n                               specs=specs,\n                               subplot_titles=subplot_titles, shared_xaxes=True, )\n\n        # GET TIMESTAMPS FOR GNSS, FORWARD, BACKWARD IF EXIST\n        gnss_timestamp = self.data_integration.data_dict['GNSS'].data.index\n        forward_timestamp = self.data_integration.filtered_state_and_variance_df_xe.index\n        backward_timestamp = self.data_integration.backward_df_xe.index if self.data_integration.backward_df_xe is not None else None\n        timestamp_min_value = self.find_min_value(gnss_timestamp, forward_timestamp,\n                                                  backward_timestamp) if backward_timestamp is not None else self.find_min_value(\n            gnss_timestamp, forward_timestamp)\n        timestamp_max_value = self.find_max_value(gnss_timestamp, forward_timestamp,\n                                                  backward_timestamp) if backward_timestamp is not None else self.find_max_value(\n            gnss_timestamp, forward_timestamp)\n\n        # CREATE DATES RANGE INCLUDING ADDITIONAL RANGE\n        additional_range_abs = additional_range * abs(timestamp_max_value - timestamp_min_value)\n        dates_range = [timestamp_min_value - additional_range_abs, timestamp_max_value + additional_range_abs]\n\n        # COLORS BY DATA TYPE\n        data_colors = {\"forward\": \"rgb(25, 255, 25)\",\n                       \"backward\": \"rgb(255, 0, 0)\",\n                       \"GNSS\": \"rgb(0, 190, 255)\",\n\n                       \"DInSAR\":[\"#0000ff\", '#1322FB', '#2541F8', '#375DF6', '#4976F3', '#5A8CF2', '#6AA0F0', '#7BB1EF', '#8AC0EF', '#9ACDEF'],\n                       \"PSI\":   [\"#771e87\", '#782390', '#792999', '#7A2FA2', '#7A36AB', '#7A3DB3', '#7A45BA', '#7B54BB', '#7E62BC', '#8370BD'],\n                       \"SBAS\":  [\"#7f822f\", '#8C8936', '#938B3E', '#9B8D46', '#A28E4E', '#A89057', '#AA9064', '#AC9372', '#AE967E', '#B19C8B'],\n                       }\n\n        disp_cols = [\"0\", \"2\", \"4\"]\n        rate_cols = [\"1\", \"3\", \"5\"]\n\n        # CREATE STORAGE FOR STORE MIN AND MAX FOR SPECIFIC DATA TYPE VALUES\n        max_disp = {\"ver\": [], \"hor\": []}\n        min_disp = {\"ver\": [], \"hor\": []}\n        max_rate = []\n        min_rate = []\n\n        # ITERATION FOR GNSS DATA\n        for i, coord in enumerate(disp_names):\n            showlegend = True if i == 0 else False\n            disp_gnss = self.data_integration.data_dict['GNSS'].data[coord]\n            disp_forward = self.data_integration.filtered_state_and_variance_df_xe[disp_cols[i]]\n            rate_forward = self.data_integration.filtered_state_and_variance_df_xe[rate_cols[i]] * 1000\n            disp_type = disp_units.get(coord, None)\n            if disp_type:\n                max_disp[disp_type].extend([max(disp_gnss), max(disp_forward)])\n                min_disp[disp_type].extend([min(disp_gnss), min(disp_forward)])\n            max_rate.extend([max(rate_forward)])\n            min_rate.extend([min(rate_forward)])\n\n            fig.add_trace(\n                go.Scatter(x=gnss_timestamp, y=disp_gnss, mode='markers', name='', showlegend=showlegend,\n                           legendgroup=\"GNSS\", legendgrouptitle_text=\"GNSS\", marker=dict(color=data_colors[\"GNSS\"], size = 8)), \n                row=1, col=i + 1)\n            fig.add_trace(\n                go.Scatter(x=forward_timestamp, y=disp_forward, mode='lines', name=name_forward, showlegend=showlegend,\n                           legendgroup=\"kalman\", legendgrouptitle_text=\"Kalman\",\n                           line=dict(width=5, color=data_colors[\"forward\"])), row=1, col=i + 1)\n            fig.add_trace(\n                go.Scatter(x=forward_timestamp, y=rate_forward, mode='lines', name=name_forward, showlegend=False,\n                           legendgroup=\"kalman\", legendgrouptitle_text=\"Kalman\",\n                           line=dict(width=5, color=data_colors[\"forward\"])), row=2, col=i + 1)\n\n            self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=1, col=i + 1)\n            self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=2, col=i + 1)\n\n            if self.data_integration.backward_df_xe is not None:\n                disp_backward = self.data_integration.backward_df_xe[disp_cols[i]]\n                rate_backward = self.data_integration.backward_df_xe[rate_cols[i]] * 1000\n\n                if disp_type:\n                    max_disp[disp_type].extend([max(disp_backward)])\n                    min_disp[disp_type].extend([min(disp_backward)])\n                max_rate.extend([max(rate_backward)])\n                min_rate.extend([min(rate_backward)])\n\n                fig.add_trace(go.Scatter(x=backward_timestamp, y=disp_backward, mode='lines', name=name_backward,\n                                         showlegend=showlegend, legendgroup=\"kalman\",\n                                         line=dict(width=4, color=data_colors[\"backward\"])), row=1, col=i + 1)\n                fig.add_trace(go.Scatter(x=backward_timestamp, y=rate_backward, mode='lines', name=name_backward,\n                                         showlegend=False, legendgroup=\"kalman\",\n                                         line=dict(width=4, color=data_colors[\"backward\"])), row=2, col=i + 1)\n\n        # ITERATION FOR SAR DATA - only DSP\n        if self.data_integration.data_dict.get('SAR') is not None:\n            for technique, data in self.data_integration.data_dict.get('SAR').items():\n                row = 3\n                if technique == \"DInSAR\" and (\"SBAS\" in self.sar_data_types or \"PSI\" in self.sar_data_types):\n                    row = 4\n                if technique == \"DInSAR\":\n                    for orbit in set(self.orbits).difference(set(data.keys())):\n                        col = self.orbits.index(orbit) + 1 if self.number_of_orbits &gt; 1 else 1\n                        fig.add_trace(\n                            go.Scatter(x=dates_range, y=pd.Series(dtype=object), mode='markers',\n                                       showlegend=False), row=row, col=col)\n                        self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=row, col=col)\n                else:\n                    for orbit in set(self.orbits).difference(set(data.keys())):\n                        col = self.orbits.index(orbit) + 1 if self.number_of_orbits &gt; 1 else 1\n                        fig.add_trace(\n                            go.Scatter(x=dates_range, y=pd.Series(dtype=object), mode='markers',\n                                       showlegend=False), row=row, col=col)\n                        self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=row, col=col)\n                if isinstance(data, dict):\n                    inner_keys = {}\n                    for orbit, orbit_data in data.items():\n                        col = self.orbits.index(orbit) + 1 if self.number_of_orbits &gt; 1 else 1\n                        if isinstance(orbit_data, dict):\n\n                            if len(self.data_integration.number_of_SAR_elements[technique]) == 1:\n                                color_index = [0]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 2:\n                                color_index = [0, 4]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 3:\n                                color_index = [0, 4, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 4:\n                                color_index = [0, 2, 4, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 5:\n                                color_index = [0, 2, 4, 6, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 6:\n                                color_index = [0, 1, 2, 4, 6, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 7:\n                                color_index = [0, 1, 2, 3, 4, 6, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 8:\n                                color_index = [0, 1, 2, 3, 4, 5, 6, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 9:\n                                color_index = [0, 1, 2, 3, 4, 5, 6, 7, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 10:\n                                color_index = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n                            for _, (subkey, subdata) in enumerate(orbit_data.items()):\n                                if subkey in inner_keys.keys():\n                                    showlegend = False\n                                else:\n                                    showlegend = True\n                                    inner_keys[subkey]=color_index[len(inner_keys)]\n\n                                color_for_data = data_colors[subdata.type][inner_keys[subkey]]\n\n                                rates = 1000 if subdata.type == \"DInSAR\" else 1\n                                if subdata.type == \"DInSAR\":\n                                    max_rate.extend([max(subdata.data[\"DSP\"] * rates)])\n                                    min_rate.extend([min(subdata.data[\"DSP\"] * rates)])\n                                else:\n                                    max_disp[\"ver\"].extend([max(subdata.data[\"DSP\"] * rates)])\n                                    min_disp[\"ver\"].extend([min(subdata.data[\"DSP\"] * rates)])\n\n                                fig.add_trace(\n                                    go.Scatter(x=subdata.data.index, y=subdata.data[\"DSP\"] * rates, mode='markers',\n                                               name=subdata.sublabel,\n                                               showlegend=showlegend, legendgroup=subdata.type,\n                                               legendgrouptitle_text=subdata.type,\n                                               marker=dict(color=color_for_data, size = 8)), row=row, col=col)\n                                self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=row, col=col)\n                        else:\n                            showlegend = True if self.orbits.index(orbit) == 0 else False\n                            rates = 1000 if orbit_data.type == \"DInSAR\" else 1\n                            if orbit_data.type == \"DInSAR\":\n                                max_rate.extend([max(orbit_data.data[\"DSP\"] * rates)])\n                                min_rate.extend([min(orbit_data.data[\"DSP\"] * rates)])\n                            else:\n                                max_disp[\"ver\"].extend([max(orbit_data.data[\"DSP\"] * rates)])\n                                min_disp[\"ver\"].extend([min(orbit_data.data[\"DSP\"] * rates)])\n\n                            fig.add_trace(\n                                go.Scatter(x=orbit_data.data.index, y=orbit_data.data[\"DSP\"] * rates, mode='markers',\n                                           name='',\n                                           showlegend=showlegend, legendgroup=orbit_data.type,\n                                           legendgrouptitle_text=orbit_data.type,\n                                           marker=dict(color=data_colors[orbit_data.type][0], size = 8)), row=row, col=col)\n                            self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=row, col=col)\n                    if technique == \"DInSAR\":\n                        for orbit in set(self.orbits).difference(set(data.keys())):\n                            col = self.orbits.index(orbit) + 1 if self.number_of_orbits &gt; 1 else 1\n                            fig.add_trace(\n                                go.Scatter(x=dates_range, y=pd.Series(dtype=object), mode='markers',\n                                           showlegend=False), row=row, col=col)\n                            self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=row, col=col)\n        if self.data_integration.mean_data_dict.get(\"DInSAR\") is not None:\n            row = 4 if (\"SBAS\" in self.sar_data_types or \"PSI\" in self.sar_data_types) else 3\n            for orbit, orbit_data in self.data_integration.mean_data_dict.get(\"DInSAR\").items():\n                col = self.orbits.index(orbit) + 1 if self.number_of_orbits &gt; 1 else 1\n\n                max_rate.extend([max(orbit_data['forward_mean'])])\n                min_rate.extend([min(orbit_data['forward_mean'])])\n\n                fig.add_trace(go.Scatter(x=orbit_data['forward_mean'].index, y=orbit_data['forward_mean'], mode='lines',\n                                         name=name_forward, showlegend=False, legendgroup=\"kalman\",\n                                         line=dict(width=5, color=data_colors[\"forward\"])), row=row, col=col)\n                if orbit_data.get('backward_mean') is not None:\n                    max_rate.extend([max(orbit_data['backward_mean'])])\n                    min_rate.extend([min(orbit_data['backward_mean'])])\n\n                    fig.add_trace(\n                        go.Scatter(x=orbit_data['backward_mean'].index, y=orbit_data['backward_mean'], mode='lines',\n                                   name=name_backward, showlegend=False, legendgroup=\"kalman\",\n                                   line=dict(width=4, color=data_colors[\"backward\"])), row=row, col=col)\n\n        if self.data_integration.mean_data_dict.get(\"SAR_SBAS_PSI_MEAN\") is not None:\n            row = 3\n            for orbit, orbit_data in self.data_integration.mean_data_dict.get(\"SAR_SBAS_PSI_MEAN\").items():\n                col = self.orbits.index(orbit) + 1 if self.number_of_orbits &gt; 1 else 1\n\n                max_disp[\"ver\"].extend([max(orbit_data['forward_mean'].dropna())])\n                min_disp[\"ver\"].extend([min(orbit_data['forward_mean'].dropna())])\n\n                fig.add_trace(\n                    go.Scatter(x=orbit_data['forward_mean'].dropna().index, y=orbit_data['forward_mean'].dropna(),\n                               mode='lines', name=name_forward, showlegend=False, legendgroup=\"kalman\",\n                               line=dict(width=5, color=data_colors[\"forward\"])), row=row, col=col)\n\n                if orbit_data.get('backward_mean') is not None:\n                    max_disp[\"ver\"].extend([max(orbit_data['backward_mean'].dropna())])\n                    min_disp[\"ver\"].extend([min(orbit_data['backward_mean'].dropna())])\n\n                    fig.add_trace(\n                        go.Scatter(x=orbit_data['backward_mean'].dropna().index, y=orbit_data['backward_mean'].dropna(),\n                                   mode='lines', name=name_backward, showlegend=False, legendgroup=\"kalman\",\n                                   line=dict(width=4, color=data_colors[\"backward\"])), row=row, col=col)\n\n        # ORDER OF TRACES FOR LEGEND\n        new_data = [trace for trace in fig.data if trace.name != name_forward] + [trace for trace in fig.data if\n                                                                                  trace.name == name_forward]\n        new_data = [trace for trace in new_data if trace.name != name_backward] + [trace for trace in new_data if\n                                                                                   trace.name == name_backward]\n        fig.data = new_data\n\n        # CREATE Y RANGE\n        max_disp_ver = self.find_max_value(max_disp[\"ver\"])\n        max_disp_hor = self.find_max_value(max_disp[\"hor\"])\n        min_disp_ver = self.find_min_value(min_disp[\"ver\"])\n        min_disp_hor = self.find_min_value(min_disp[\"hor\"])\n\n        min_rate = self.find_min_value(min_rate)\n        max_rate = self.find_max_value(max_rate)\n\n        range_ver = [min_disp_ver - additional_range * abs(max_disp_ver - min_disp_ver),\n                     max_disp_ver + additional_range * abs(max_disp_ver - min_disp_ver)]\n        range_hor = [min_disp_hor - additional_range * abs(max_disp_hor - min_disp_hor),\n                     max_disp_hor + additional_range * abs(max_disp_hor - min_disp_hor)]\n        range_rate = [min_rate - additional_range * abs(max_rate - min_rate),\n                      max_rate + additional_range * abs(max_rate - min_rate)]\n\n        min_range_value = 0.05\n        if min(range_ver[0], range_hor[0]) &gt; -min_range_value and max(range_ver[1], range_hor[1]) &lt; min_range_value:\n            range_ver = [-min_range_value, min_range_value]\n            range_hor = [-min_range_value, min_range_value]\n\n        # UPDATE X AND Y RANGE FOR GNSS DISPLACEMENT    \n        fig.update_yaxes(range=range_hor,   row=1, col=1)\n        fig.update_yaxes(range=range_hor,   row=1, col=2)\n        fig.update_yaxes(range=range_ver,   row=1, col=3)\n        fig.update_xaxes(range=dates_range, row=1)\n\n        # UPDATE X AND Y RANGE FOR GNSS RATE\n        fig.update_xaxes(range=dates_range, row=2)\n        fig.update_yaxes(range=range_rate,  row=2)\n\n        # UPDATE X AND Y RANGE FOR DInSAR OR PSI&amp; SBAS\n        fig.update_xaxes(range=dates_range, row=3)\n        if rows == 4 and \"DInSAR\" in self.sar_data_types: \n            fig.update_yaxes(range=range_rate, row=3)\n        else:\n            fig.update_yaxes(range=range_ver,  row=3)\n\n        # UPDATE X AND Y RANGE FOR DInSAR WITH PSI&amp; SBAS\n        fig.update_xaxes(range=dates_range, row=4)\n        fig.update_yaxes(range=range_rate,  row=4)\n\n\n        # UPDATE EVERY ANNOTATIONS -&gt; FONT SIZE\n        fig.update_annotations(font_size=24, font_color = 'black')\n\n        layout_settings = {\n            'title_text': f\"MultiDEFusion: &lt;b&gt;{self.data_integration.station}&lt;/b&gt;\",\n            'font': dict(family='Helvetica', size=20, color = 'black'),\n            'height': 1400,\n            'width': 1600,\n            'showlegend': True,\n            'margin' : dict(r=10,b=10),\n            'legend': dict(orientation='h',\n                           # groupclick=\"toggleitem\",\n                           itemsizing='constant',\n                           bordercolor='black',\n                           borderwidth=1,\n                           yanchor=\"bottom\",\n                           y=vertical_postition['1'][1]+shift_legend,\n                           xanchor=\"right\",\n                           x=1),\n            'plot_bgcolor': 'white',\n        }\n\n        axis_settings = {\n            'gridcolor': 'lightgray',\n            'ticks': 'inside',\n            'linecolor': 'black',\n            'mirror': 'ticks',\n            'color': 'black',\n            'minor': dict(gridcolor='lightgray', gridwidth=0.1, ticks='inside', tickcolor='black'),\n            'automargin': 'height+width+left+right',    \n        }\n\n        # UPDATE POSITION AND SETTINGS FOR GNSS DISPLACEMENT\n        for i in range(1, 4):\n            layout_settings[f'xaxis{i}'] = dict(domain=subplots_postition[\"3\"][i - 1], showticklabels=False, hoverformat = '%d %b %Y',\n                                                **axis_settings)\n            layout_settings[f'yaxis{i}'] = dict(\n                domain=vertical_postition['1'],\n                title='&lt;b&gt;Displacement [m]&lt;/b&gt;' if i == 1 else '',\n                showticklabels=True if i == 1 or i == 3 else False,\n                tickformat='.2f',\n                zeroline=True,\n                zerolinewidth=2,\n                zerolinecolor='lightgray',\n                hoverformat = '.3f',\n                **axis_settings\n            )\n        # UPDATE POSITION AND SETTINGS FOR GNSS RATE\n        for i in range(1, 4):\n            layout_settings[f'xaxis{i + 3}'] = dict(domain=subplots_postition[\"3\"][i - 1],\n                                                    showticklabels=True, tickformat='%b&lt;br&gt;%Y', hoverformat = '%d %b %Y', **axis_settings)\n            layout_settings[f'yaxis{i + 3}'] = dict(\n                domain=vertical_postition['2'],\n                title='&lt;b&gt;Rate&lt;br&gt;[mm/day]&lt;/b&gt;' if i == 1 else '',\n                showticklabels=True if i == 1 or i == 3 else False,\n                tickformat='.2f',\n                zeroline=True,\n                zerolinewidth=2,\n                zerolinecolor='lightgray',\n                hoverformat = '.1f',\n                **axis_settings\n            )\n\n        if self.number_of_orbits == 3:\n            subplots_postition_orbits = str(self.number_of_orbits) + \"*\"\n        else:\n            subplots_postition_orbits = str(self.number_of_orbits)\n\n\n\n        table_vertical  = table_postition['GNSS']\n        table_title_pos = shift_title_fig*5\n        picker_position = custom_position['GNSS']\n\n        if rows == 4:\n            if \"DInSAR\" in self.sar_data_types and len(self.sar_data_types) == 1:\n                table_vertical  = table_postition['DInSAR']\n                table_title_pos = shift_title_fig*5\n                picker_position = custom_position['DInSAR']\n                for i in range(1, len(self.orbits) + 1):\n                    layout_settings[f'xaxis{i + 6}'] = dict(\n                        domain=subplots_postition[subplots_postition_orbits][i - 1],\n                        tickformat='%b&lt;br&gt;%Y', hoverformat = '%d %b %Y', **axis_settings)\n                    layout_settings[f'yaxis{i + 6}'] = dict(\n                        domain=vertical_postition['3*'],\n                        title='&lt;b&gt;Rate&lt;br&gt;[mm/day]&lt;/b&gt;' if i == 1 else '',\n                        showticklabels=True if i == 1 else False,\n                        tickformat='.2f',\n                        zeroline=True,\n                        zerolinewidth=2,\n                        zerolinecolor='lightgray',\n                        hoverformat = '.1f',\n                        **axis_settings\n                    )\n\n        if rows == 4:\n            if \"DInSAR\" not in self.sar_data_types and len(self.sar_data_types) &gt; 0:\n                table_vertical  = table_postition['SBAS']\n                table_title_pos = shift_title_fig\n                picker_position = custom_position['SBAS']\n                for i in range(1, len(self.orbits) + 1):\n                    layout_settings[f'xaxis{i + 6}'] = dict(\n                        domain=subplots_postition[subplots_postition_orbits][i - 1],\n                        tickformat='%b&lt;br&gt;%Y', hoverformat = '%d %b %Y', **axis_settings)\n                    layout_settings[f'yaxis{i + 6}'] = dict(\n                        domain=vertical_postition['3'],\n                        title='&lt;b&gt;Displacement [m]&lt;/b&gt;' if i == 1 else '',\n                        showticklabels=True if i == 1 else False,\n                        tickformat='.2f',\n                        zeroline=True,\n                        zerolinewidth=2,\n                        zerolinecolor='lightgray',\n                        hoverformat = '.3f',\n                        **axis_settings\n                    )\n\n        if rows == 5:\n            table_vertical  = table_postition['MSAR']\n            table_title_pos = shift_title_fig\n            picker_position = custom_position['MSAR']\n            for i in range(1, len(self.orbits) + 1):\n                layout_settings[f'xaxis{i + 6}'] = dict(domain=subplots_postition[subplots_postition_orbits][i - 1],\n                                                        showticklabels=False, hoverformat = '%d %b %Y', **axis_settings)\n                layout_settings[f'yaxis{i + 6}'] = dict(\n                    domain=vertical_postition['3'],\n                    title='&lt;b&gt;Displacement [m]&lt;/b&gt;' if i == 1 else '',\n                    showticklabels=True if i == 1 else False,\n                    tickformat='.2f',\n                    zeroline=True,\n                    zerolinewidth=2,            \n                    zerolinecolor='lightgray',\n                    hoverformat = '.3f',\n                    **axis_settings\n                )\n                layout_settings[f'xaxis{i + 6 + len(self.orbits)}'] = dict(\n                    domain=subplots_postition[subplots_postition_orbits][i - 1],\n                    tickformat='%b&lt;br&gt;%Y', hoverformat = '%d %b %Y', **axis_settings)\n                layout_settings[f'yaxis{i + 6 + len(self.orbits)}'] = dict(\n                    domain=vertical_postition['4'],\n                    title='&lt;b&gt;Rate&lt;br&gt;[mm/day]&lt;/b&gt;' if i == 1 else '',\n                    showticklabels=True if i == 1 else False,\n                    tickformat='.2f',\n                    zeroline=True,\n                    zerolinewidth=2,\n                    zerolinecolor='lightgray',\n                    hoverformat = '.1f',\n                    **axis_settings\n                )\n\n        fig.update_layout(**layout_settings)\n\n        fig.update_layout(xaxis=dict(matches='x'),\n                          xaxis4=dict(matches='x'),\n                          xaxis2=dict(matches='x2'),\n                          xaxis5=dict(matches='x2'),\n                          xaxis3=dict(matches='x3'),\n                          xaxis6=dict(matches='x3'),\n                          hovermode='x unified',\n                          )\n\n        fig.update_traces(hovertemplate='%{y} %{xother}')\n\n        if self.data_integration.backward_df_xe is not None:\n            max_total_values = self.find_max_total(self.data_integration.backward_df_xe)\n            mean_rate = self.data_integration.backward_df_xe.mean()\n            kalman_col = '  Kalman&lt;br&gt;Backward'\n        else:\n            kalman_col = ' Kalman&lt;br&gt;Forward'\n            max_total_values = self.find_max_total(self.data_integration.filtered_state_and_variance_df_xe)\n            mean_rate = self.data_integration.filtered_state_and_variance_df_xe.mean()\n\n\n        fig.add_trace(go.Table(\n            header=dict(values=[f\"{kalman_col}\", '     Max&lt;br&gt;  DEF [m]',  'Mean rate&lt;br&gt;  [m/year]'],\n                        align='center',\n                        fill_color = 'rgb(189, 215, 231)',\n                        line_color='black',\n                        font = dict(color = 'black', size = 24)),\n            cells =dict(values=[['North', 'East', 'Up'], max_total_values[disp_cols].apply(lambda x: f'{x:.3f}'), (mean_rate[rate_cols]*365.25).apply(lambda x: f'{x:.3f}')], \n                        align='center', \n                        height=41.5,\n                        fill_color = 'white',\n                        line_color='black',\n                        font = dict(color = 'black', size = 24))\n            ), row=rows, col=1)\n\n        fig.update_traces(\n            domain={'y': table_vertical, 'x': subplots_postition['3'][1]},\n            selector={'type': 'table'})\n\n        for annotation, domain in zip(fig['layout']['annotations'][:3], subplots_postition[\"3\"]):\n            annotation['x'] = (domain[0] + domain[1]) / 2\n            annotation['y'] = vertical_postition['1'][1]+shift_title_fig\n\n        if self.number_of_orbits == 3:\n            subplots_pos = subplots_postition[\"3*\"]\n        elif self.number_of_orbits in [1, 2]:\n            subplots_pos = subplots_postition[str(self.number_of_orbits)]\n\n        if rows &gt; 3:\n            for annotation, domain in zip(fig['layout']['annotations'][3:], subplots_pos):\n                annotation['x'] = (domain[0] + domain[1]) / 2\n                annotation['y'] = vertical_postition['3'][1]+shift_title_fig\n\n        fig.add_annotation(\n            x = mean(subplots_postition['3'][1]),\n            y = table_vertical[1]+table_title_pos,\n            xref = \"paper\",\n            yref = \"paper\",\n            showarrow=False,\n            font_size = 25,\n            font_color = 'black',\n            text = \"&lt;b&gt;Relevant values&lt;/b&gt;\")\n\n        fig.add_annotation(\n            x = mean(subplots_postition['3'][1]),\n            y = 0.005,\n            xref = \"paper\",\n            yref = \"paper\",\n            showarrow=False,\n            font_family = 'Helvetica',\n            font_size = 15,\n            font_color = 'black',\n            text = \"The Kalman filter displacements and rates shown for InSAR orbits in the Line of Sight (LOS) domain were determined based on the mean heading and incidence angle values.\")\n\n        #DASH PART\n        app = dash.Dash(__name__)\n        container1 = html.Div([\n            dcc.Graph(\n                id='subplot-graph',\n                figure = fig,\n                config = {\n                    'toImageButtonOptions': {'format': 'svg', 'filename': 'MultiDEFusion_'+self.data_integration.station},\n                    'displaylogo': False,\n                    'showEditInChartStudio': True,\n                    'plotlyServerURL': \"https://chart-studio.plotly.com\",\n                    'modeBarButtonsToRemove': ['select', 'lasso2d', 'autoScale'],\n                    'modeBarButtonsToAdd': ['zoomIn2d', 'zoomOut2d', 'drawline', 'drawcircle', 'drawrect', 'eraseshape', 'sendDataToCloud']\n                    }\n            ),])\n\n        container2 = html.Div([\n            html.H2('Customise dates range',\n                    style={'fontsize': '25px',\n                           'margin-bottom': '5px'}),\n\n\t\t    dcc.DatePickerRange(\n\t\t\t\tid='date_range',\n\t\t\t\t#initial_visible_month=dates_range[0],\n\t\t\t\tdisplay_format='DD/MM/YYYY',\n\t\t\t\tshow_outside_days = True,\n\t\t\t\tstart_date=dates_range[0],\n\t\t\t\tend_date=dates_range[1],\n                number_of_months_shown=2,\n                style={'border': '2px solid black',\n                       'margin-bottom': '10px'},\n\t\t\t),\n\n            html.Div(id='output_x_range',\n                     style={'fontsize': '15px',\n                            'color': 'red'}),\n\n            html.H2('Customise values range',\n                    style={'fontsize': '25px',\n                           'margin-bottom': '5px'}),\n\n            dcc.Dropdown(\n                id = 'show_or_hide',\n                options=[\n                    {'label': 'Horizontal range [m]', 'value': 'hor'},\n                    {'label': 'Vertical &amp; LOS range [m]', 'value': 'ver'},\n                    {'label': 'Rate range [mm/day]', 'value': 'rate'}\n                ],\n                value = 'hor',\n                clearable = False,\n                style={'width': '286px',\n                       'font-size': '20px', \n                       'border': '0.2px solid black',\n                       'border-radius': '0',\n                       'height': '40px', \n                       'margin-bottom': '5px'},\n            ),\n\n            html.Div(id = 'hor_options', children=[\n                dcc.Input(\n                id = 'hor_min',\n                placeholder = 'Minimum value',\n                type='number',\n                step = 0.001,\n                value = float(\"{:.3f}\".format(range_hor[0])),\n                style = {'font-size': '17px',\n                         'border': '1px solid black',\n                         'height': '30px', \n                         'width': '138px'}\n                ),\n\n                dcc.Input(\n                id = 'hor_max',\n                placeholder = 'Maximum value',\n                type='number',\n                step = 0.001,\n                value = float(\"{:.3f}\".format(range_hor[1])),\n                style = {'font-size': '17px',\n                         'border': '1px solid black',\n                         'height': '30px', \n                         'width': '138px'}\n                )\n            ],\n            style={'display': 'block',\n                   'margin-bottom': '10px'},\n            ),\n\n            html.Div(id = 'ver_options', children=[\n                dcc.Input(\n                id = 'ver_min',\n                placeholder = 'Minimum value',\n                type='number',\n                step = 0.001,\n                value = float(\"{:.3f}\".format(range_ver[0])),\n                style = {'font-size': '17px',\n                         'border': '1px solid black',\n                         'height': '30px', \n                         'width': '138px'}\n                ),\n\n                dcc.Input(\n                id = 'ver_max',\n                placeholder = 'Maximum value',\n                type='number',\n                step = 0.001,\n                value = float(\"{:.3f}\".format(range_ver[1])),\n                style = {'font-size': '17px',\n                         'border': '1px solid black',\n                         'height': '30px', \n                         'width': '138px'}\n                )\n            ],\n            style={'display': 'block',\n                   'margin-bottom': '10px'},\n            ),\n\n            html.Div(id = 'rate_options', children=[\n                dcc.Input(\n                id = 'rate_min',\n                placeholder = 'Minimum value',\n                type='number',\n                step = 0.1,\n                value = float(\"{:.1f}\".format(range_rate[0])),\n                style = {'font-size': '17px',\n                         'border': '1px solid black',\n                         'height': '30px', \n                         'width': '138px'}\n                ),\n\n                dcc.Input(\n                id = 'rate_max',\n                placeholder = 'Maximum value',\n                type='number',\n                step = 0.1,\n                value = float(\"{:.1f}\".format(range_rate[1])),\n                style = {'font-size': '17px', \n                         'border': '1px solid black',\n                         'height': '30px', \n                         'width': '138px'}\n                )\n            ],\n            style={'display': 'block',\n                   'margin-bottom': '10px'},\n            ),\n\n            html.Div(id='output_y_range',\n                     style={'fontsize': '15px',\n                            'color': 'red'}\n                     )\n        ], \n        style={'position': 'absolute', \n               'top': f'{picker_position}px', \n               'left': '155px', \n               'width': 'fit-content',\n               'fontFamily': 'Helvetica',\n               'color': 'black', \n               }\n        )\n\n        app.layout = html.Div([container1, container2])\n\n        @app.callback(\n           Output('hor_options', 'style'),\n           Output('ver_options', 'style'),\n           Output('rate_options', 'style'),\n           Input('show_or_hide', 'value'))\n\n        def show_hide_element(visibility_state):\n            if visibility_state == 'hor':\n                return {'display': 'block'}, {'display': 'none'}, {'display': 'none'}\n            elif visibility_state == 'ver':\n                return {'display': 'none'}, {'display': 'block'}, {'display': 'none'}\n            else:\n                return {'display': 'none'}, {'display': 'none'}, {'display': 'block'}\n\n        @app.callback(\n           Output('subplot-graph', 'figure'),\n           Output('output_x_range', 'children'),\n           Output('output_y_range', 'children'),\n           [Input('date_range', 'start_date'),\n            Input('date_range', 'end_date'),\n            Input('hor_min', 'value'), \n            Input('hor_max', 'value'),\n            Input('ver_min', 'value'), \n            Input('ver_max', 'value'),\n            Input('rate_min', 'value'), \n            Input('rate_max', 'value')]\n           )\n\n        def update_subplot(start_date, end_date, hor_min, hor_max, ver_min, ver_max, rate_min, rate_max):\n\n            warning_dates = None\n            if end_date &lt;= start_date and end_date is not None and start_date is not None:\n                warning_dates = 'The end date must be greater than the start date!'\n            if warning_dates == None:\n                fig.update_xaxes(range=(start_date, end_date))\n\n            warning_values = None\n            if hor_min is not None and hor_max is not None and hor_max &lt;= hor_min:\n                warning_values = 'Maximum value must be greater than minimum!'\n            if ver_min is not None and ver_max is not None and ver_max &lt;= ver_min:\n                warning_values = 'Maximum value must be greater than minimum!'\n            if rate_min is not None and rate_max is not None and rate_max &lt;= rate_min:\n                warning_values = 'Maximum value must be greater than minimum!'\n            if warning_values == None:                \n                # UPDATE Y RANGE FOR GNSS DISPLACEMENT    \n                fig.update_yaxes(range=[hor_min, hor_max], row=1, col=1)\n                fig.update_yaxes(range=[hor_min, hor_max], row=1, col=2)\n                fig.update_yaxes(range=[ver_min, ver_max], row=1, col=3)\n\n                # UPDATE X AND Y RANGE FOR GNSS RATE\n                fig.update_yaxes(range=[rate_min, rate_max], row=2)\n\n                # UPDATE X AND Y RANGE FOR DInSAR OR PSI &amp; SBAS\n                if rows == 4 and \"DInSAR\" in self.sar_data_types: \n                    fig.update_yaxes(range=[rate_min, rate_max], row=3)\n                else:\n                    fig.update_yaxes(range=[ver_min, ver_max], row=3)\n\n                # UPDATE X AND Y RANGE FOR DInSAR WITH PSI&amp; SBAS\n                fig.update_yaxes(range=[rate_min, rate_max], row=4)\n\n            return fig, warning_dates, warning_values\n\n\n        print(\"MultiDEFusion procedure accomplished.\\n\")\n        app.run_server(debug=True, host=\"localhost\", port=self.data_integration.port);\n        webbrowser.open(f'http://localhost:{self.data_integration.port}')\n</code></pre>"},{"location":"results/#multidefusion.results.Figures.__init__","title":"<code>__init__(data_integration)</code>","text":"<p>Initialize Figures object.</p> <p>Parameters:</p> Name Type Description Default <code>data_integration</code> <code>object</code> <p>Object containing integrated data.</p> required Source code in <code>multidefusion\\results.py</code> <pre><code>def __init__(self, data_integration):\n    \"\"\"\n    Initialize Figures object.\n\n    Args:\n        data_integration (object): Object containing integrated data.\n    \"\"\"\n    self.data_integration = data_integration\n    sar_data = self.data_integration.data_dict.get(\"SAR\")\n    if sar_data is not None:\n        list_of_orbits = list(set(orbit for technique_data in sar_data.values() for orbit in technique_data))\n        list_of_orbits = [int(x) for x in list_of_orbits]\n        list_of_orbits.sort()\n        list_of_orbits = [str(x) for x in list_of_orbits]\n        self.orbits = list_of_orbits\n        self.number_of_orbits = len(self.orbits)\n        self.sar_data_types = list(set([data for data in self.data_integration.data_dict.get(\"SAR\").keys()]))\n    else:\n        self.orbits = []\n        self.number_of_orbits = 0\n        self.sar_data_types = []\n</code></pre>"},{"location":"results/#multidefusion.results.Figures.create_displacement_plot","title":"<code>create_displacement_plot()</code>","text":"<p>Create displacement plot using Plotly and Dash.</p> Source code in <code>multidefusion\\results.py</code> <pre><code>    def create_displacement_plot(self):\n        \"\"\"\n        Create displacement plot using Plotly and Dash.\n        \"\"\"\n        # SETTINGS\n        print(\"Development of a figure...\")\n        additional_range = 0.05  # additional +/-5% of range for plots by x and y axis\n        golden_ratio = (1 + 5 ** 0.5) / 2  # for size on y axis\n        subplots_postition = {'3*': [[0.019, 0.335], [0.342, 0.658], [0.665, 0.981]],\n                              '3' : [[0.000, 0.316], [0.323, 0.639], [0.684, 1.000]],\n                              '2' : [[0.1805, 0.4965], [0.5035, 0.8195]],\n                              '1' : [[0.323, 0.639]]}\n\n        shift_rate_fig  = 0.007\n        shift_disp_fig  = 0.100\n        shift_title_fig = 0.003\n        shift_legend    = 0.030\n        rate_fig_size   = 7/25\n        top_limit_plot  = 0.970\n        vertical_postition = {}\n        vertical_postition['1']  = [top_limit_plot-subplots_postition['3'][0][1]/golden_ratio, top_limit_plot]\n        vertical_postition['2']  = [vertical_postition['1'][0]-subplots_postition['3'][0][1]/golden_ratio*rate_fig_size-shift_rate_fig , vertical_postition['1'][0]-shift_rate_fig]\n        vertical_postition['3*'] = [vertical_postition['2'][0]-subplots_postition['3'][0][1]/golden_ratio*rate_fig_size-shift_disp_fig , vertical_postition['2'][0]-shift_disp_fig]\n        vertical_postition['3']  = [vertical_postition['2'][0]-subplots_postition['3'][0][1]/golden_ratio              -shift_disp_fig , vertical_postition['2'][0]-shift_disp_fig]\n        vertical_postition['4']  = [vertical_postition['3'][0]-subplots_postition['3'][0][1]/golden_ratio*rate_fig_size-shift_rate_fig , vertical_postition['3'][0]-shift_rate_fig]\n\n        table_postition = {'GNSS'  : [vertical_postition['2'][0]-subplots_postition['3'][0][1]/golden_ratio-shift_disp_fig, vertical_postition['2'][0]-shift_disp_fig],\n                           'DInSAR': [vertical_postition['3*'][0]-subplots_postition['3'][0][1]/golden_ratio-shift_disp_fig, vertical_postition['3*'][0]-shift_disp_fig],\n                           'SBAS'  : [vertical_postition['3'][0]-subplots_postition['3'][0][1]/golden_ratio-shift_disp_fig, vertical_postition['3'][0]-shift_disp_fig],\n                           'MSAR'  : [vertical_postition['4'][0]-subplots_postition['3'][0][1]/golden_ratio-shift_disp_fig, vertical_postition['4'][0]-shift_disp_fig]}\n\n        shift_dash = 0\n        max_len_elements = max(len(lst) for lst in self.data_integration.number_of_SAR_elements.values())\n        if max_len_elements &gt; 2:\n            shift_dash = (max_len_elements-2)*7\n\n        custom_position = {'GNSS'  : 558,\n                           'DInSAR': 754+shift_dash,\n                           'SBAS'  : 929+shift_dash,\n                           'MSAR'  : 1009+shift_dash}\n\n        rows = 3\n        cols = 3\n        specs = [[{\"type\": \"xy\"}] * cols for _ in range(rows-1)]\n\n        name_forward = \"Forward\"\n        name_backward = \"Backward\"\n\n        GNSS_names = [\"North\", \"East\", \"Up\"]\n        disp_names = [\"N\", \"E\", \"U\"]\n        disp_units = {\"U\": \"ver\", \"N\": \"hor\", \"E\": \"hor\"}\n\n        subplot_titles = [f\"&lt;b&gt;{GNSS_names[0]}&lt;/b&gt;\", f\"&lt;b&gt;{GNSS_names[1]}&lt;/b&gt;\", f\"&lt;b&gt;{GNSS_names[2]}&lt;/b&gt;\"] + [''] * cols\n\n        orbit_titles = [\"&lt;b&gt;Orbit \" + orbit + \"&lt;/b&gt;\" for orbit in self.orbits]\n        empty_titles = [\"\"] * (3 - self.number_of_orbits)\n        # CREATE GRID FOR SUBPLOTS AND TITLES\n        if \"PSI\" in self.sar_data_types or \"SBAS\" in self.sar_data_types:\n            rows += 1\n            subplot_titles.extend(orbit_titles + empty_titles)\n\n            specs_temp = [[{\"type\": \"xy\"}] * self.number_of_orbits + [None] * (3 - self.number_of_orbits)]\n            specs.extend(specs_temp)\n\n        if \"DInSAR\" in self.sar_data_types:\n            rows += 1\n            specs_temp = [[{\"type\": \"xy\"}] * self.number_of_orbits + [None] * (3 - self.number_of_orbits)]\n            specs.extend(specs_temp)\n            if \"PSI\" not in self.sar_data_types and \"SBAS\" not in self.sar_data_types:\n                subplot_titles.extend(orbit_titles + empty_titles)\n            else:\n                subplot_titles.extend([\"\"] * self.number_of_orbits)\n\n        specs_temp = [ [{\"type\": \"table\"}] + [None]*2]\n        specs.extend(specs_temp)\n\n        # CREATE FIG OBJECT\n        fig = sp.make_subplots(rows=rows, cols=cols,\n                               specs=specs,\n                               subplot_titles=subplot_titles, shared_xaxes=True, )\n\n        # GET TIMESTAMPS FOR GNSS, FORWARD, BACKWARD IF EXIST\n        gnss_timestamp = self.data_integration.data_dict['GNSS'].data.index\n        forward_timestamp = self.data_integration.filtered_state_and_variance_df_xe.index\n        backward_timestamp = self.data_integration.backward_df_xe.index if self.data_integration.backward_df_xe is not None else None\n        timestamp_min_value = self.find_min_value(gnss_timestamp, forward_timestamp,\n                                                  backward_timestamp) if backward_timestamp is not None else self.find_min_value(\n            gnss_timestamp, forward_timestamp)\n        timestamp_max_value = self.find_max_value(gnss_timestamp, forward_timestamp,\n                                                  backward_timestamp) if backward_timestamp is not None else self.find_max_value(\n            gnss_timestamp, forward_timestamp)\n\n        # CREATE DATES RANGE INCLUDING ADDITIONAL RANGE\n        additional_range_abs = additional_range * abs(timestamp_max_value - timestamp_min_value)\n        dates_range = [timestamp_min_value - additional_range_abs, timestamp_max_value + additional_range_abs]\n\n        # COLORS BY DATA TYPE\n        data_colors = {\"forward\": \"rgb(25, 255, 25)\",\n                       \"backward\": \"rgb(255, 0, 0)\",\n                       \"GNSS\": \"rgb(0, 190, 255)\",\n\n                       \"DInSAR\":[\"#0000ff\", '#1322FB', '#2541F8', '#375DF6', '#4976F3', '#5A8CF2', '#6AA0F0', '#7BB1EF', '#8AC0EF', '#9ACDEF'],\n                       \"PSI\":   [\"#771e87\", '#782390', '#792999', '#7A2FA2', '#7A36AB', '#7A3DB3', '#7A45BA', '#7B54BB', '#7E62BC', '#8370BD'],\n                       \"SBAS\":  [\"#7f822f\", '#8C8936', '#938B3E', '#9B8D46', '#A28E4E', '#A89057', '#AA9064', '#AC9372', '#AE967E', '#B19C8B'],\n                       }\n\n        disp_cols = [\"0\", \"2\", \"4\"]\n        rate_cols = [\"1\", \"3\", \"5\"]\n\n        # CREATE STORAGE FOR STORE MIN AND MAX FOR SPECIFIC DATA TYPE VALUES\n        max_disp = {\"ver\": [], \"hor\": []}\n        min_disp = {\"ver\": [], \"hor\": []}\n        max_rate = []\n        min_rate = []\n\n        # ITERATION FOR GNSS DATA\n        for i, coord in enumerate(disp_names):\n            showlegend = True if i == 0 else False\n            disp_gnss = self.data_integration.data_dict['GNSS'].data[coord]\n            disp_forward = self.data_integration.filtered_state_and_variance_df_xe[disp_cols[i]]\n            rate_forward = self.data_integration.filtered_state_and_variance_df_xe[rate_cols[i]] * 1000\n            disp_type = disp_units.get(coord, None)\n            if disp_type:\n                max_disp[disp_type].extend([max(disp_gnss), max(disp_forward)])\n                min_disp[disp_type].extend([min(disp_gnss), min(disp_forward)])\n            max_rate.extend([max(rate_forward)])\n            min_rate.extend([min(rate_forward)])\n\n            fig.add_trace(\n                go.Scatter(x=gnss_timestamp, y=disp_gnss, mode='markers', name='', showlegend=showlegend,\n                           legendgroup=\"GNSS\", legendgrouptitle_text=\"GNSS\", marker=dict(color=data_colors[\"GNSS\"], size = 8)), \n                row=1, col=i + 1)\n            fig.add_trace(\n                go.Scatter(x=forward_timestamp, y=disp_forward, mode='lines', name=name_forward, showlegend=showlegend,\n                           legendgroup=\"kalman\", legendgrouptitle_text=\"Kalman\",\n                           line=dict(width=5, color=data_colors[\"forward\"])), row=1, col=i + 1)\n            fig.add_trace(\n                go.Scatter(x=forward_timestamp, y=rate_forward, mode='lines', name=name_forward, showlegend=False,\n                           legendgroup=\"kalman\", legendgrouptitle_text=\"Kalman\",\n                           line=dict(width=5, color=data_colors[\"forward\"])), row=2, col=i + 1)\n\n            self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=1, col=i + 1)\n            self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=2, col=i + 1)\n\n            if self.data_integration.backward_df_xe is not None:\n                disp_backward = self.data_integration.backward_df_xe[disp_cols[i]]\n                rate_backward = self.data_integration.backward_df_xe[rate_cols[i]] * 1000\n\n                if disp_type:\n                    max_disp[disp_type].extend([max(disp_backward)])\n                    min_disp[disp_type].extend([min(disp_backward)])\n                max_rate.extend([max(rate_backward)])\n                min_rate.extend([min(rate_backward)])\n\n                fig.add_trace(go.Scatter(x=backward_timestamp, y=disp_backward, mode='lines', name=name_backward,\n                                         showlegend=showlegend, legendgroup=\"kalman\",\n                                         line=dict(width=4, color=data_colors[\"backward\"])), row=1, col=i + 1)\n                fig.add_trace(go.Scatter(x=backward_timestamp, y=rate_backward, mode='lines', name=name_backward,\n                                         showlegend=False, legendgroup=\"kalman\",\n                                         line=dict(width=4, color=data_colors[\"backward\"])), row=2, col=i + 1)\n\n        # ITERATION FOR SAR DATA - only DSP\n        if self.data_integration.data_dict.get('SAR') is not None:\n            for technique, data in self.data_integration.data_dict.get('SAR').items():\n                row = 3\n                if technique == \"DInSAR\" and (\"SBAS\" in self.sar_data_types or \"PSI\" in self.sar_data_types):\n                    row = 4\n                if technique == \"DInSAR\":\n                    for orbit in set(self.orbits).difference(set(data.keys())):\n                        col = self.orbits.index(orbit) + 1 if self.number_of_orbits &gt; 1 else 1\n                        fig.add_trace(\n                            go.Scatter(x=dates_range, y=pd.Series(dtype=object), mode='markers',\n                                       showlegend=False), row=row, col=col)\n                        self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=row, col=col)\n                else:\n                    for orbit in set(self.orbits).difference(set(data.keys())):\n                        col = self.orbits.index(orbit) + 1 if self.number_of_orbits &gt; 1 else 1\n                        fig.add_trace(\n                            go.Scatter(x=dates_range, y=pd.Series(dtype=object), mode='markers',\n                                       showlegend=False), row=row, col=col)\n                        self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=row, col=col)\n                if isinstance(data, dict):\n                    inner_keys = {}\n                    for orbit, orbit_data in data.items():\n                        col = self.orbits.index(orbit) + 1 if self.number_of_orbits &gt; 1 else 1\n                        if isinstance(orbit_data, dict):\n\n                            if len(self.data_integration.number_of_SAR_elements[technique]) == 1:\n                                color_index = [0]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 2:\n                                color_index = [0, 4]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 3:\n                                color_index = [0, 4, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 4:\n                                color_index = [0, 2, 4, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 5:\n                                color_index = [0, 2, 4, 6, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 6:\n                                color_index = [0, 1, 2, 4, 6, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 7:\n                                color_index = [0, 1, 2, 3, 4, 6, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 8:\n                                color_index = [0, 1, 2, 3, 4, 5, 6, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 9:\n                                color_index = [0, 1, 2, 3, 4, 5, 6, 7, 8]\n                            elif len(self.data_integration.number_of_SAR_elements[technique]) == 10:\n                                color_index = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n                            for _, (subkey, subdata) in enumerate(orbit_data.items()):\n                                if subkey in inner_keys.keys():\n                                    showlegend = False\n                                else:\n                                    showlegend = True\n                                    inner_keys[subkey]=color_index[len(inner_keys)]\n\n                                color_for_data = data_colors[subdata.type][inner_keys[subkey]]\n\n                                rates = 1000 if subdata.type == \"DInSAR\" else 1\n                                if subdata.type == \"DInSAR\":\n                                    max_rate.extend([max(subdata.data[\"DSP\"] * rates)])\n                                    min_rate.extend([min(subdata.data[\"DSP\"] * rates)])\n                                else:\n                                    max_disp[\"ver\"].extend([max(subdata.data[\"DSP\"] * rates)])\n                                    min_disp[\"ver\"].extend([min(subdata.data[\"DSP\"] * rates)])\n\n                                fig.add_trace(\n                                    go.Scatter(x=subdata.data.index, y=subdata.data[\"DSP\"] * rates, mode='markers',\n                                               name=subdata.sublabel,\n                                               showlegend=showlegend, legendgroup=subdata.type,\n                                               legendgrouptitle_text=subdata.type,\n                                               marker=dict(color=color_for_data, size = 8)), row=row, col=col)\n                                self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=row, col=col)\n                        else:\n                            showlegend = True if self.orbits.index(orbit) == 0 else False\n                            rates = 1000 if orbit_data.type == \"DInSAR\" else 1\n                            if orbit_data.type == \"DInSAR\":\n                                max_rate.extend([max(orbit_data.data[\"DSP\"] * rates)])\n                                min_rate.extend([min(orbit_data.data[\"DSP\"] * rates)])\n                            else:\n                                max_disp[\"ver\"].extend([max(orbit_data.data[\"DSP\"] * rates)])\n                                min_disp[\"ver\"].extend([min(orbit_data.data[\"DSP\"] * rates)])\n\n                            fig.add_trace(\n                                go.Scatter(x=orbit_data.data.index, y=orbit_data.data[\"DSP\"] * rates, mode='markers',\n                                           name='',\n                                           showlegend=showlegend, legendgroup=orbit_data.type,\n                                           legendgrouptitle_text=orbit_data.type,\n                                           marker=dict(color=data_colors[orbit_data.type][0], size = 8)), row=row, col=col)\n                            self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=row, col=col)\n                    if technique == \"DInSAR\":\n                        for orbit in set(self.orbits).difference(set(data.keys())):\n                            col = self.orbits.index(orbit) + 1 if self.number_of_orbits &gt; 1 else 1\n                            fig.add_trace(\n                                go.Scatter(x=dates_range, y=pd.Series(dtype=object), mode='markers',\n                                           showlegend=False), row=row, col=col)\n                            self.add_vline(fig, timestamp_min_value, timestamp_max_value, row=row, col=col)\n        if self.data_integration.mean_data_dict.get(\"DInSAR\") is not None:\n            row = 4 if (\"SBAS\" in self.sar_data_types or \"PSI\" in self.sar_data_types) else 3\n            for orbit, orbit_data in self.data_integration.mean_data_dict.get(\"DInSAR\").items():\n                col = self.orbits.index(orbit) + 1 if self.number_of_orbits &gt; 1 else 1\n\n                max_rate.extend([max(orbit_data['forward_mean'])])\n                min_rate.extend([min(orbit_data['forward_mean'])])\n\n                fig.add_trace(go.Scatter(x=orbit_data['forward_mean'].index, y=orbit_data['forward_mean'], mode='lines',\n                                         name=name_forward, showlegend=False, legendgroup=\"kalman\",\n                                         line=dict(width=5, color=data_colors[\"forward\"])), row=row, col=col)\n                if orbit_data.get('backward_mean') is not None:\n                    max_rate.extend([max(orbit_data['backward_mean'])])\n                    min_rate.extend([min(orbit_data['backward_mean'])])\n\n                    fig.add_trace(\n                        go.Scatter(x=orbit_data['backward_mean'].index, y=orbit_data['backward_mean'], mode='lines',\n                                   name=name_backward, showlegend=False, legendgroup=\"kalman\",\n                                   line=dict(width=4, color=data_colors[\"backward\"])), row=row, col=col)\n\n        if self.data_integration.mean_data_dict.get(\"SAR_SBAS_PSI_MEAN\") is not None:\n            row = 3\n            for orbit, orbit_data in self.data_integration.mean_data_dict.get(\"SAR_SBAS_PSI_MEAN\").items():\n                col = self.orbits.index(orbit) + 1 if self.number_of_orbits &gt; 1 else 1\n\n                max_disp[\"ver\"].extend([max(orbit_data['forward_mean'].dropna())])\n                min_disp[\"ver\"].extend([min(orbit_data['forward_mean'].dropna())])\n\n                fig.add_trace(\n                    go.Scatter(x=orbit_data['forward_mean'].dropna().index, y=orbit_data['forward_mean'].dropna(),\n                               mode='lines', name=name_forward, showlegend=False, legendgroup=\"kalman\",\n                               line=dict(width=5, color=data_colors[\"forward\"])), row=row, col=col)\n\n                if orbit_data.get('backward_mean') is not None:\n                    max_disp[\"ver\"].extend([max(orbit_data['backward_mean'].dropna())])\n                    min_disp[\"ver\"].extend([min(orbit_data['backward_mean'].dropna())])\n\n                    fig.add_trace(\n                        go.Scatter(x=orbit_data['backward_mean'].dropna().index, y=orbit_data['backward_mean'].dropna(),\n                                   mode='lines', name=name_backward, showlegend=False, legendgroup=\"kalman\",\n                                   line=dict(width=4, color=data_colors[\"backward\"])), row=row, col=col)\n\n        # ORDER OF TRACES FOR LEGEND\n        new_data = [trace for trace in fig.data if trace.name != name_forward] + [trace for trace in fig.data if\n                                                                                  trace.name == name_forward]\n        new_data = [trace for trace in new_data if trace.name != name_backward] + [trace for trace in new_data if\n                                                                                   trace.name == name_backward]\n        fig.data = new_data\n\n        # CREATE Y RANGE\n        max_disp_ver = self.find_max_value(max_disp[\"ver\"])\n        max_disp_hor = self.find_max_value(max_disp[\"hor\"])\n        min_disp_ver = self.find_min_value(min_disp[\"ver\"])\n        min_disp_hor = self.find_min_value(min_disp[\"hor\"])\n\n        min_rate = self.find_min_value(min_rate)\n        max_rate = self.find_max_value(max_rate)\n\n        range_ver = [min_disp_ver - additional_range * abs(max_disp_ver - min_disp_ver),\n                     max_disp_ver + additional_range * abs(max_disp_ver - min_disp_ver)]\n        range_hor = [min_disp_hor - additional_range * abs(max_disp_hor - min_disp_hor),\n                     max_disp_hor + additional_range * abs(max_disp_hor - min_disp_hor)]\n        range_rate = [min_rate - additional_range * abs(max_rate - min_rate),\n                      max_rate + additional_range * abs(max_rate - min_rate)]\n\n        min_range_value = 0.05\n        if min(range_ver[0], range_hor[0]) &gt; -min_range_value and max(range_ver[1], range_hor[1]) &lt; min_range_value:\n            range_ver = [-min_range_value, min_range_value]\n            range_hor = [-min_range_value, min_range_value]\n\n        # UPDATE X AND Y RANGE FOR GNSS DISPLACEMENT    \n        fig.update_yaxes(range=range_hor,   row=1, col=1)\n        fig.update_yaxes(range=range_hor,   row=1, col=2)\n        fig.update_yaxes(range=range_ver,   row=1, col=3)\n        fig.update_xaxes(range=dates_range, row=1)\n\n        # UPDATE X AND Y RANGE FOR GNSS RATE\n        fig.update_xaxes(range=dates_range, row=2)\n        fig.update_yaxes(range=range_rate,  row=2)\n\n        # UPDATE X AND Y RANGE FOR DInSAR OR PSI&amp; SBAS\n        fig.update_xaxes(range=dates_range, row=3)\n        if rows == 4 and \"DInSAR\" in self.sar_data_types: \n            fig.update_yaxes(range=range_rate, row=3)\n        else:\n            fig.update_yaxes(range=range_ver,  row=3)\n\n        # UPDATE X AND Y RANGE FOR DInSAR WITH PSI&amp; SBAS\n        fig.update_xaxes(range=dates_range, row=4)\n        fig.update_yaxes(range=range_rate,  row=4)\n\n\n        # UPDATE EVERY ANNOTATIONS -&gt; FONT SIZE\n        fig.update_annotations(font_size=24, font_color = 'black')\n\n        layout_settings = {\n            'title_text': f\"MultiDEFusion: &lt;b&gt;{self.data_integration.station}&lt;/b&gt;\",\n            'font': dict(family='Helvetica', size=20, color = 'black'),\n            'height': 1400,\n            'width': 1600,\n            'showlegend': True,\n            'margin' : dict(r=10,b=10),\n            'legend': dict(orientation='h',\n                           # groupclick=\"toggleitem\",\n                           itemsizing='constant',\n                           bordercolor='black',\n                           borderwidth=1,\n                           yanchor=\"bottom\",\n                           y=vertical_postition['1'][1]+shift_legend,\n                           xanchor=\"right\",\n                           x=1),\n            'plot_bgcolor': 'white',\n        }\n\n        axis_settings = {\n            'gridcolor': 'lightgray',\n            'ticks': 'inside',\n            'linecolor': 'black',\n            'mirror': 'ticks',\n            'color': 'black',\n            'minor': dict(gridcolor='lightgray', gridwidth=0.1, ticks='inside', tickcolor='black'),\n            'automargin': 'height+width+left+right',    \n        }\n\n        # UPDATE POSITION AND SETTINGS FOR GNSS DISPLACEMENT\n        for i in range(1, 4):\n            layout_settings[f'xaxis{i}'] = dict(domain=subplots_postition[\"3\"][i - 1], showticklabels=False, hoverformat = '%d %b %Y',\n                                                **axis_settings)\n            layout_settings[f'yaxis{i}'] = dict(\n                domain=vertical_postition['1'],\n                title='&lt;b&gt;Displacement [m]&lt;/b&gt;' if i == 1 else '',\n                showticklabels=True if i == 1 or i == 3 else False,\n                tickformat='.2f',\n                zeroline=True,\n                zerolinewidth=2,\n                zerolinecolor='lightgray',\n                hoverformat = '.3f',\n                **axis_settings\n            )\n        # UPDATE POSITION AND SETTINGS FOR GNSS RATE\n        for i in range(1, 4):\n            layout_settings[f'xaxis{i + 3}'] = dict(domain=subplots_postition[\"3\"][i - 1],\n                                                    showticklabels=True, tickformat='%b&lt;br&gt;%Y', hoverformat = '%d %b %Y', **axis_settings)\n            layout_settings[f'yaxis{i + 3}'] = dict(\n                domain=vertical_postition['2'],\n                title='&lt;b&gt;Rate&lt;br&gt;[mm/day]&lt;/b&gt;' if i == 1 else '',\n                showticklabels=True if i == 1 or i == 3 else False,\n                tickformat='.2f',\n                zeroline=True,\n                zerolinewidth=2,\n                zerolinecolor='lightgray',\n                hoverformat = '.1f',\n                **axis_settings\n            )\n\n        if self.number_of_orbits == 3:\n            subplots_postition_orbits = str(self.number_of_orbits) + \"*\"\n        else:\n            subplots_postition_orbits = str(self.number_of_orbits)\n\n\n\n        table_vertical  = table_postition['GNSS']\n        table_title_pos = shift_title_fig*5\n        picker_position = custom_position['GNSS']\n\n        if rows == 4:\n            if \"DInSAR\" in self.sar_data_types and len(self.sar_data_types) == 1:\n                table_vertical  = table_postition['DInSAR']\n                table_title_pos = shift_title_fig*5\n                picker_position = custom_position['DInSAR']\n                for i in range(1, len(self.orbits) + 1):\n                    layout_settings[f'xaxis{i + 6}'] = dict(\n                        domain=subplots_postition[subplots_postition_orbits][i - 1],\n                        tickformat='%b&lt;br&gt;%Y', hoverformat = '%d %b %Y', **axis_settings)\n                    layout_settings[f'yaxis{i + 6}'] = dict(\n                        domain=vertical_postition['3*'],\n                        title='&lt;b&gt;Rate&lt;br&gt;[mm/day]&lt;/b&gt;' if i == 1 else '',\n                        showticklabels=True if i == 1 else False,\n                        tickformat='.2f',\n                        zeroline=True,\n                        zerolinewidth=2,\n                        zerolinecolor='lightgray',\n                        hoverformat = '.1f',\n                        **axis_settings\n                    )\n\n        if rows == 4:\n            if \"DInSAR\" not in self.sar_data_types and len(self.sar_data_types) &gt; 0:\n                table_vertical  = table_postition['SBAS']\n                table_title_pos = shift_title_fig\n                picker_position = custom_position['SBAS']\n                for i in range(1, len(self.orbits) + 1):\n                    layout_settings[f'xaxis{i + 6}'] = dict(\n                        domain=subplots_postition[subplots_postition_orbits][i - 1],\n                        tickformat='%b&lt;br&gt;%Y', hoverformat = '%d %b %Y', **axis_settings)\n                    layout_settings[f'yaxis{i + 6}'] = dict(\n                        domain=vertical_postition['3'],\n                        title='&lt;b&gt;Displacement [m]&lt;/b&gt;' if i == 1 else '',\n                        showticklabels=True if i == 1 else False,\n                        tickformat='.2f',\n                        zeroline=True,\n                        zerolinewidth=2,\n                        zerolinecolor='lightgray',\n                        hoverformat = '.3f',\n                        **axis_settings\n                    )\n\n        if rows == 5:\n            table_vertical  = table_postition['MSAR']\n            table_title_pos = shift_title_fig\n            picker_position = custom_position['MSAR']\n            for i in range(1, len(self.orbits) + 1):\n                layout_settings[f'xaxis{i + 6}'] = dict(domain=subplots_postition[subplots_postition_orbits][i - 1],\n                                                        showticklabels=False, hoverformat = '%d %b %Y', **axis_settings)\n                layout_settings[f'yaxis{i + 6}'] = dict(\n                    domain=vertical_postition['3'],\n                    title='&lt;b&gt;Displacement [m]&lt;/b&gt;' if i == 1 else '',\n                    showticklabels=True if i == 1 else False,\n                    tickformat='.2f',\n                    zeroline=True,\n                    zerolinewidth=2,            \n                    zerolinecolor='lightgray',\n                    hoverformat = '.3f',\n                    **axis_settings\n                )\n                layout_settings[f'xaxis{i + 6 + len(self.orbits)}'] = dict(\n                    domain=subplots_postition[subplots_postition_orbits][i - 1],\n                    tickformat='%b&lt;br&gt;%Y', hoverformat = '%d %b %Y', **axis_settings)\n                layout_settings[f'yaxis{i + 6 + len(self.orbits)}'] = dict(\n                    domain=vertical_postition['4'],\n                    title='&lt;b&gt;Rate&lt;br&gt;[mm/day]&lt;/b&gt;' if i == 1 else '',\n                    showticklabels=True if i == 1 else False,\n                    tickformat='.2f',\n                    zeroline=True,\n                    zerolinewidth=2,\n                    zerolinecolor='lightgray',\n                    hoverformat = '.1f',\n                    **axis_settings\n                )\n\n        fig.update_layout(**layout_settings)\n\n        fig.update_layout(xaxis=dict(matches='x'),\n                          xaxis4=dict(matches='x'),\n                          xaxis2=dict(matches='x2'),\n                          xaxis5=dict(matches='x2'),\n                          xaxis3=dict(matches='x3'),\n                          xaxis6=dict(matches='x3'),\n                          hovermode='x unified',\n                          )\n\n        fig.update_traces(hovertemplate='%{y} %{xother}')\n\n        if self.data_integration.backward_df_xe is not None:\n            max_total_values = self.find_max_total(self.data_integration.backward_df_xe)\n            mean_rate = self.data_integration.backward_df_xe.mean()\n            kalman_col = '  Kalman&lt;br&gt;Backward'\n        else:\n            kalman_col = ' Kalman&lt;br&gt;Forward'\n            max_total_values = self.find_max_total(self.data_integration.filtered_state_and_variance_df_xe)\n            mean_rate = self.data_integration.filtered_state_and_variance_df_xe.mean()\n\n\n        fig.add_trace(go.Table(\n            header=dict(values=[f\"{kalman_col}\", '     Max&lt;br&gt;  DEF [m]',  'Mean rate&lt;br&gt;  [m/year]'],\n                        align='center',\n                        fill_color = 'rgb(189, 215, 231)',\n                        line_color='black',\n                        font = dict(color = 'black', size = 24)),\n            cells =dict(values=[['North', 'East', 'Up'], max_total_values[disp_cols].apply(lambda x: f'{x:.3f}'), (mean_rate[rate_cols]*365.25).apply(lambda x: f'{x:.3f}')], \n                        align='center', \n                        height=41.5,\n                        fill_color = 'white',\n                        line_color='black',\n                        font = dict(color = 'black', size = 24))\n            ), row=rows, col=1)\n\n        fig.update_traces(\n            domain={'y': table_vertical, 'x': subplots_postition['3'][1]},\n            selector={'type': 'table'})\n\n        for annotation, domain in zip(fig['layout']['annotations'][:3], subplots_postition[\"3\"]):\n            annotation['x'] = (domain[0] + domain[1]) / 2\n            annotation['y'] = vertical_postition['1'][1]+shift_title_fig\n\n        if self.number_of_orbits == 3:\n            subplots_pos = subplots_postition[\"3*\"]\n        elif self.number_of_orbits in [1, 2]:\n            subplots_pos = subplots_postition[str(self.number_of_orbits)]\n\n        if rows &gt; 3:\n            for annotation, domain in zip(fig['layout']['annotations'][3:], subplots_pos):\n                annotation['x'] = (domain[0] + domain[1]) / 2\n                annotation['y'] = vertical_postition['3'][1]+shift_title_fig\n\n        fig.add_annotation(\n            x = mean(subplots_postition['3'][1]),\n            y = table_vertical[1]+table_title_pos,\n            xref = \"paper\",\n            yref = \"paper\",\n            showarrow=False,\n            font_size = 25,\n            font_color = 'black',\n            text = \"&lt;b&gt;Relevant values&lt;/b&gt;\")\n\n        fig.add_annotation(\n            x = mean(subplots_postition['3'][1]),\n            y = 0.005,\n            xref = \"paper\",\n            yref = \"paper\",\n            showarrow=False,\n            font_family = 'Helvetica',\n            font_size = 15,\n            font_color = 'black',\n            text = \"The Kalman filter displacements and rates shown for InSAR orbits in the Line of Sight (LOS) domain were determined based on the mean heading and incidence angle values.\")\n\n        #DASH PART\n        app = dash.Dash(__name__)\n        container1 = html.Div([\n            dcc.Graph(\n                id='subplot-graph',\n                figure = fig,\n                config = {\n                    'toImageButtonOptions': {'format': 'svg', 'filename': 'MultiDEFusion_'+self.data_integration.station},\n                    'displaylogo': False,\n                    'showEditInChartStudio': True,\n                    'plotlyServerURL': \"https://chart-studio.plotly.com\",\n                    'modeBarButtonsToRemove': ['select', 'lasso2d', 'autoScale'],\n                    'modeBarButtonsToAdd': ['zoomIn2d', 'zoomOut2d', 'drawline', 'drawcircle', 'drawrect', 'eraseshape', 'sendDataToCloud']\n                    }\n            ),])\n\n        container2 = html.Div([\n            html.H2('Customise dates range',\n                    style={'fontsize': '25px',\n                           'margin-bottom': '5px'}),\n\n\t\t    dcc.DatePickerRange(\n\t\t\t\tid='date_range',\n\t\t\t\t#initial_visible_month=dates_range[0],\n\t\t\t\tdisplay_format='DD/MM/YYYY',\n\t\t\t\tshow_outside_days = True,\n\t\t\t\tstart_date=dates_range[0],\n\t\t\t\tend_date=dates_range[1],\n                number_of_months_shown=2,\n                style={'border': '2px solid black',\n                       'margin-bottom': '10px'},\n\t\t\t),\n\n            html.Div(id='output_x_range',\n                     style={'fontsize': '15px',\n                            'color': 'red'}),\n\n            html.H2('Customise values range',\n                    style={'fontsize': '25px',\n                           'margin-bottom': '5px'}),\n\n            dcc.Dropdown(\n                id = 'show_or_hide',\n                options=[\n                    {'label': 'Horizontal range [m]', 'value': 'hor'},\n                    {'label': 'Vertical &amp; LOS range [m]', 'value': 'ver'},\n                    {'label': 'Rate range [mm/day]', 'value': 'rate'}\n                ],\n                value = 'hor',\n                clearable = False,\n                style={'width': '286px',\n                       'font-size': '20px', \n                       'border': '0.2px solid black',\n                       'border-radius': '0',\n                       'height': '40px', \n                       'margin-bottom': '5px'},\n            ),\n\n            html.Div(id = 'hor_options', children=[\n                dcc.Input(\n                id = 'hor_min',\n                placeholder = 'Minimum value',\n                type='number',\n                step = 0.001,\n                value = float(\"{:.3f}\".format(range_hor[0])),\n                style = {'font-size': '17px',\n                         'border': '1px solid black',\n                         'height': '30px', \n                         'width': '138px'}\n                ),\n\n                dcc.Input(\n                id = 'hor_max',\n                placeholder = 'Maximum value',\n                type='number',\n                step = 0.001,\n                value = float(\"{:.3f}\".format(range_hor[1])),\n                style = {'font-size': '17px',\n                         'border': '1px solid black',\n                         'height': '30px', \n                         'width': '138px'}\n                )\n            ],\n            style={'display': 'block',\n                   'margin-bottom': '10px'},\n            ),\n\n            html.Div(id = 'ver_options', children=[\n                dcc.Input(\n                id = 'ver_min',\n                placeholder = 'Minimum value',\n                type='number',\n                step = 0.001,\n                value = float(\"{:.3f}\".format(range_ver[0])),\n                style = {'font-size': '17px',\n                         'border': '1px solid black',\n                         'height': '30px', \n                         'width': '138px'}\n                ),\n\n                dcc.Input(\n                id = 'ver_max',\n                placeholder = 'Maximum value',\n                type='number',\n                step = 0.001,\n                value = float(\"{:.3f}\".format(range_ver[1])),\n                style = {'font-size': '17px',\n                         'border': '1px solid black',\n                         'height': '30px', \n                         'width': '138px'}\n                )\n            ],\n            style={'display': 'block',\n                   'margin-bottom': '10px'},\n            ),\n\n            html.Div(id = 'rate_options', children=[\n                dcc.Input(\n                id = 'rate_min',\n                placeholder = 'Minimum value',\n                type='number',\n                step = 0.1,\n                value = float(\"{:.1f}\".format(range_rate[0])),\n                style = {'font-size': '17px',\n                         'border': '1px solid black',\n                         'height': '30px', \n                         'width': '138px'}\n                ),\n\n                dcc.Input(\n                id = 'rate_max',\n                placeholder = 'Maximum value',\n                type='number',\n                step = 0.1,\n                value = float(\"{:.1f}\".format(range_rate[1])),\n                style = {'font-size': '17px', \n                         'border': '1px solid black',\n                         'height': '30px', \n                         'width': '138px'}\n                )\n            ],\n            style={'display': 'block',\n                   'margin-bottom': '10px'},\n            ),\n\n            html.Div(id='output_y_range',\n                     style={'fontsize': '15px',\n                            'color': 'red'}\n                     )\n        ], \n        style={'position': 'absolute', \n               'top': f'{picker_position}px', \n               'left': '155px', \n               'width': 'fit-content',\n               'fontFamily': 'Helvetica',\n               'color': 'black', \n               }\n        )\n\n        app.layout = html.Div([container1, container2])\n\n        @app.callback(\n           Output('hor_options', 'style'),\n           Output('ver_options', 'style'),\n           Output('rate_options', 'style'),\n           Input('show_or_hide', 'value'))\n\n        def show_hide_element(visibility_state):\n            if visibility_state == 'hor':\n                return {'display': 'block'}, {'display': 'none'}, {'display': 'none'}\n            elif visibility_state == 'ver':\n                return {'display': 'none'}, {'display': 'block'}, {'display': 'none'}\n            else:\n                return {'display': 'none'}, {'display': 'none'}, {'display': 'block'}\n\n        @app.callback(\n           Output('subplot-graph', 'figure'),\n           Output('output_x_range', 'children'),\n           Output('output_y_range', 'children'),\n           [Input('date_range', 'start_date'),\n            Input('date_range', 'end_date'),\n            Input('hor_min', 'value'), \n            Input('hor_max', 'value'),\n            Input('ver_min', 'value'), \n            Input('ver_max', 'value'),\n            Input('rate_min', 'value'), \n            Input('rate_max', 'value')]\n           )\n\n        def update_subplot(start_date, end_date, hor_min, hor_max, ver_min, ver_max, rate_min, rate_max):\n\n            warning_dates = None\n            if end_date &lt;= start_date and end_date is not None and start_date is not None:\n                warning_dates = 'The end date must be greater than the start date!'\n            if warning_dates == None:\n                fig.update_xaxes(range=(start_date, end_date))\n\n            warning_values = None\n            if hor_min is not None and hor_max is not None and hor_max &lt;= hor_min:\n                warning_values = 'Maximum value must be greater than minimum!'\n            if ver_min is not None and ver_max is not None and ver_max &lt;= ver_min:\n                warning_values = 'Maximum value must be greater than minimum!'\n            if rate_min is not None and rate_max is not None and rate_max &lt;= rate_min:\n                warning_values = 'Maximum value must be greater than minimum!'\n            if warning_values == None:                \n                # UPDATE Y RANGE FOR GNSS DISPLACEMENT    \n                fig.update_yaxes(range=[hor_min, hor_max], row=1, col=1)\n                fig.update_yaxes(range=[hor_min, hor_max], row=1, col=2)\n                fig.update_yaxes(range=[ver_min, ver_max], row=1, col=3)\n\n                # UPDATE X AND Y RANGE FOR GNSS RATE\n                fig.update_yaxes(range=[rate_min, rate_max], row=2)\n\n                # UPDATE X AND Y RANGE FOR DInSAR OR PSI &amp; SBAS\n                if rows == 4 and \"DInSAR\" in self.sar_data_types: \n                    fig.update_yaxes(range=[rate_min, rate_max], row=3)\n                else:\n                    fig.update_yaxes(range=[ver_min, ver_max], row=3)\n\n                # UPDATE X AND Y RANGE FOR DInSAR WITH PSI&amp; SBAS\n                fig.update_yaxes(range=[rate_min, rate_max], row=4)\n\n            return fig, warning_dates, warning_values\n\n\n        print(\"MultiDEFusion procedure accomplished.\\n\")\n        app.run_server(debug=True, host=\"localhost\", port=self.data_integration.port);\n        webbrowser.open(f'http://localhost:{self.data_integration.port}')\n</code></pre>"},{"location":"results/#multidefusion.results.Figures.find_max_value","title":"<code>find_max_value(*lists)</code>  <code>staticmethod</code>","text":"<p>Find the maximum value from a set of lists.</p> <p>Parameters:</p> Name Type Description Default <code>*lists</code> <p>Variable number of lists to find the maximum value from.</p> <code>()</code> <p>Returns:</p> Type Description <p>Maximum value from the provided lists.</p> Source code in <code>multidefusion\\results.py</code> <pre><code>@staticmethod\ndef find_max_value(*lists):\n    \"\"\"\n    Find the maximum value from a set of lists.\n\n    Args:\n        *lists: Variable number of lists to find the maximum value from.\n\n    Returns:\n        Maximum value from the provided lists.\n    \"\"\"\n    if not lists:\n        return None\n    flattened_list = [item for sublist in lists for item in sublist]\n    return max(flattened_list)\n</code></pre>"},{"location":"results/#multidefusion.results.Figures.find_min_value","title":"<code>find_min_value(*lists)</code>  <code>staticmethod</code>","text":"<p>Find the minimum value from a set of lists.</p> <p>Parameters:</p> Name Type Description Default <code>*lists</code> <p>Variable number of lists to find the minimum value from.</p> <code>()</code> <p>Returns:</p> Type Description <p>Minimum value from the provided lists.</p> Source code in <code>multidefusion\\results.py</code> <pre><code>@staticmethod\ndef find_min_value(*lists):\n    \"\"\"\n    Find the minimum value from a set of lists.\n\n    Args:\n        *lists: Variable number of lists to find the minimum value from.\n\n    Returns:\n        Minimum value from the provided lists.\n    \"\"\"\n    if not lists:\n        return None\n    flattened_list = [item for sublist in lists for item in sublist]\n    return min(flattened_list)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use multidefusion in a project:</p> <pre><code>import multidefusion\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print('Hello World!')\n</pre> print('Hello World!') <pre>Hello World!\n</pre>"}]}